# ポケモンタイプ予測プロジェクト

このプロジェクトは、ポケモンの画像に基づいてそのタイプを予測することに焦点を当てています。これには、PokeAPIからのデータ取得、画像処理、データセットの作成、そしてポケモンのタイプのマルチラベル分類のための畳み込みニューラルネットワーク（CNN）モデルの開発と評価が含まれます。

## プロジェクトの構成

プロジェクトは、それぞれがパイプラインの特定の側面を処理する複数のPythonスクリプトで構成されています。

-   `get_data_from_POKEAPI.py`: PokeAPIからポケモンのデータ（名前、タイプ、世代、種族値など）を取得し、JSONファイル（`poke_data.json`）として保存する役割を担います。また、ポケモンの画像をダウンロードし、PNGファイルとして保存します。
-   `json_and_png_check.py`: ポケモンの画像（PNGファイル）を読み込み、PyTorchテンソルに前処理するためのユーティリティ関数を含んでいます。画像を96x96ピクセルの均一なサイズにパディングし、透明な背景をフィルタリングする関数が含まれています。このスクリプトは、ダウンロードされたJSONおよびPNGデータの初期チェックにも使用されました。
-   `make_dataset.py`: ポケモンの画像とそれに対応するタイプラベルを読み込むためのカスタムPyTorch `Dataset`である`PokeDataset`クラスを定義します。トレーニングプロセスを強化するためのデータ拡張技術が組み込まれています。
-   `utils.py`: ポケモンのタイプを数値インデックスにマッピングし、その逆を行うためのユーティリティ辞書を提供します。
-   `type_predictor.py`: ポケモンタイプ予測のための基本的なCNNモデルを実装しています。このスクリプトは、モデルのトレーニングと評価に使用され、トレーニングとテストの損失、および精度を視覚化します。
-   `class_balanced_type_predictor.py`: より洗練されたアーキテクチャを持つ改良されたCNNモデル（`TypePredictor`）が含まれており、クラスの不均衡を処理するための`pos_weight`を持つ`BCEWithLogitsLoss`、および学習率スケジューリングのための`ReduceLROnPlateau`が組み込まれています。これは、改良されたモデルをトレーニングするための主要なスクリプトです。
-   `test_models.py`: トレーニング済みモデル、特に`class_balanced`モデルの評価に使用されます。これは、全体的な精度、Micro F1スコア、Macro F1スコアを計算し、いくつかのサンプルの予測結果を視覚化します。

## セットアップとインストール

このプロジェクトをセットアップして実行するには、次の手順に従います。

1.  **リポジトリのクローン:**
    ```bash
    git clone <repository_url>
    cd <repository_name>
    ```

2.  **仮想環境の作成（推奨）:**
    ```bash
    python -m venv venv
    source venv/bin/activate  # Windowsの場合: `venv\Scripts\activate`
    ```

3.  **必要なライブラリのインストール:**
    ```bash
    pip install torch torchvision requests Pillow matplotlib scikit-learn tqdm
    ```

## 使い方

### 1. データ取得

まず、ポケモンのデータと画像をダウンロードする必要があります。`get_data_from_POKEAPI.py`スクリプトを実行します。

```bash
python get_data_from_POKEAPI.py
```

これにより、次のものが作成されます。
-   `poke_data.json`: 各ポケモンの詳細情報（ID、名前、タイプ、世代、種族値）を含むJSONファイル。
-   `poke_png/`: ポケモンのPNG画像を含むディレクトリ。

### 2. モデルトレーニング（クラスバランス予測器）

クラスバランスと学習率スケジューリングを含む改良されたタイプ予測モデルをトレーニングするには、次を実行します。

```bash
python class_balanced_type_predictor.py
```

このスクリプトは次のことを行います。
-   ポケモンのデータを読み込み、トレーニング（第1〜8世代）とテスト（第9世代）のセットに分割します。
-   トレーニング中にデータ拡張を適用します。
-   クラスの不均衡に対処するために`BCEWithLogitsLoss`の`pos_weight`を計算します。
-   `TypePredictor`モデルをトレーニングし、その状態辞書を`model_states/class_balanced.pth`に保存します。
-   エポックごとのトレーニング損失とテスト損失のプロットを表示します。

### 3. モデル評価

トレーニング済みモデルのパフォーマンスを評価するには、次を実行します。

```bash
python test_models.py
```

このスクリプトは次のことを行います。
-   事前にトレーニングされた`class_balanced.pth`モデルを読み込みます。
-   テストデータセット（第9世代ポケモン）でモデルを評価します。
-   全体的な精度、Micro F1スコア、Macro F1スコアを出力します。
-   テストセットからいくつかのランダムなサンプルの予測タイプを、真のタイプと確率分布とともに視覚化して表示します。

### 4. 基本モデル（オプション）

基本的な`type_predictor.py`モデルをトレーニングおよび評価することもできます。

```bash
python type_predictor.py
```

このスクリプトは、よりシンプルなCNNアーキテクチャを提供し、損失と精度のプロットも表示します。

## モデルアーキテクチャ (class_balanced_type_predictor.py)

`TypePredictor`モデルは、マルチラベル分類用に設計された畳み込みニューラルネットワークです。

-   **`conv_block`**: 3つの入力チャネル、16の出力チャネル、3x3カーネル、1x1パディングを持つ2D畳み込みを適用し、その後ReLU活性化と2x2最大プーリング層を適用します。これにより、画像サイズは48x48に縮小されます。
-   **`conv_block2`**: `conv_block`の出力を、別の2D畳み込み（16の入力チャネル、32の出力チャネル、3x3カーネル、1x1パディング）、ReLU、および2x2最大プーリング層でさらに処理します。出力サイズは24x24になります。
-   **`poolpool`**: 元の入力`x`に直接2つの連続した2x2最大プーリング操作を適用し、3x24x24のテンソルを生成します。
-   **連結**: `conv_block2`と`poolpool`の出力はチャネル次元に沿って連結され、高レベルの特徴とダウンサンプリングされた元の画像情報が結合されます。これにより、`(3 + out_channels2) * 24 * 24`サイズのテンソルが生成されます。
-   **全結合層**: 連結された特徴は平坦化され、2つの線形層（`fc1`と`fc2`）を通過し、その間にTanh活性化とドロップアウトが適用されます。最終的な`fc2`層は18個の値をM出力し、これは18種類のポケモンタイプに対応します。

## 依存関係

-   `torch`
-   `torchvision`
-   `requests`
-   `Pillow`
-   `matplotlib`
-   `scikit-learn`
-   `tqdm`

## 今後の改善点

-   転移学習を用いた手法を試す。
-   より洗練されたデータ拡張戦略を実装する。
-   さまざまな損失関数と最適化手法を検討する。
-   最初の1025種類以外のポケモンのデータを追加することを検討する。
-   ユーザーが予測のために画像をアップロードできるWebインターフェースまたはシンプルなアプリケーションを開発する。